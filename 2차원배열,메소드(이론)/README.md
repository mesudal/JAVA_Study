# 2차원 배열, 메소드 이론 공부

<h3>2차원 배열의 정의</h3>
<ul>
  <li>2차원 배열 : 배열 안에 배열을 생성</li>
  <li>사용하는 이유 : 1차원 배열을 여러 개 선언할 때 관리하기 힘들기 때문에 2차원 배열을 한 번에 선언</li>
  <li>2차원 이상의 배열은 메모리 낭비가 심하므로 선호하지 않음.</li>
  <li>2차원 배열은 실무에서 크게 쓰진 않지만, DB에서 관리할 때 기본적인 개념이 필요하기 때문에 학습 필요</li>
</ul>








<h3>2차원 배열의 예시</h3>
<ul>
  <li>쉽게 이해하면, "아파트 101동"이라는 배열에 "101호, 102호, 103호, 201호, ..."라는 배열을 만드는 것이다.</li>
  <li>접근 순서는 행(가로)->열(세로)로 진행이 된다.</li>
  <li>예시를 좀 더 정확하게 이해해보도록 하자.</li>
  <ul>
    <li>아파트라는 이름을 가진 배열이 존재하고, 배열 안에는 101동, 102동, 103동이 있다. </li>
    <li>각 동 안에는 세대주, 매매 or 전세 or 월세, 연락처 이렇게 3가지 정보가 있다.</li>
    <li>즉, arApt[] = [101동 or 102동 or 103동][세대주 or 전세 or 월세]</li>
  </ul>
  <img src="https://postfiles.pstatic.net/MjAyMjA4MDJfMzMg/MDAxNjU5NDA1OTgxMDU4.FzSVqYkTjkCagDuy6wWyIyYCK4wnVxIsRxo7BGMu-bAg.9aKnx6_t6gcGY1Wg9yBG-ViyBuB5iJw99hyAUjmXAmcg.PNG.mesudal/image.png?type=w773">
</ul>


<h3>2차원 배열 선언방법</h3>
<p>자료형 배열명[][] = {{값1, 값2, 값3}, {값4, ...}, ...};<br>
자료형 배열명[][] = new 자료형[행][열];<br>
자료형 배열명[][] = null;<br>
배열명 = new 자료형[행][열];<br>
</p>


<h3>2차원 배열 length</h3>
<ul>
  <li>2차원 배열의 길이를 구할 때 arrData.length를 쓰게 되면 행의 길이를 출력하게 된다.</li>
  <li>열의 길이를 구하고 싶을 경우 arrData[행].length로 작성을 하면 열의 길이를 출력하게 된다.</li>
</ul>


<h3>2중 for문</h3>
<ul>
  <li>2중 for문 : 말그대로 for문 안에 for문이 또 하나 있는 것이다.</li>
  <li>2차원 배열을 사용할 때 2중 for문을 활용하면 복잡하지 않게 배열 안의 인덱스와 인덱스 값을 확인할 수 있다.</li>
  <li>2중 for문의 예시</li>
  <pre><code>
    int cnt = 0;
      for(int i = 0; i < 10; i++) {
        for (int j = 0; j < 3; j++) {
          cnt++;
          System.out.println(cnt);
        }
      }
</code></pre>
</ul>



<h3>메소드</h3>
<ul>
  <li>이름 뒤에 소괄호가 붙은 코드.</li>
  <ul>
    <li>키워드 뒤에 소괄호는 메소드가 아님(if, switch, for 등등)</li>
    <li>Ex) "f(x) = 2x + 1"를 본다고 했을 때, f는 메소드의 이름을 의미하고 (x)는 매개변수가 된다. 2x + 1은 리턴값이 된다.</li>
  </ul>
</ul>


<h3>메소드 선언방법</h3>
<pre><code>
    (1)리턴타입 (2)메소드명(자료형 (3)매개변수명, ...) {
    (4)실행할 문장;
    (5)return 리턴값;
}
</code></pre>
<ul>
  <li>(1) : 리턴값이 있다면 리턴값의 자료형을 작성하고, 리턴값이 없다면 void를 작성한다</li>
  <li>(2) : 동사로 작성해야 한다 (Ex : eat(banana))</li>
  <li>(3) : 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해주어야 한다</li>
  <li>(4) : 생략이 가능하며, 메소드의 기능을 구현하는 로직을 작성한다</li>
  <li>(5) : 생략이 가능하다</li>
</ul>


<h3>메소드의 선언 순서</h3>
<ul>
  <li>메소드의 이름을 생각한다. (sum, plus, add, getTotal, ...)</li>
  <li>선언을 할 때는 메소드 뒤에 { }중괄호가 붙고, 사용을 할 때는 { }중괄호가 붙지 않는다.</li>
  <li>소괄호 안에 집어넣을 매개변수를 생각한다.</li>
  <li>실행할 문장(=코드) 생각하여 작성한다.</li>
  <li>메소드의 목적에 맞는 리턴값을 알아보기 쉽게 return한다.</li>
</ul>


<h3>메소드 주의사항</h3>
<ul>
  <li>메소드는 클래스 안에, 메소드 밖에서 선언이 가능하다.</li>
  <li>메소드를 사용할 때는, 반드시 메소드 안에서 사용한다.</li>
</ul>


<h3>메소드 사용</h3>
<ul>
  <li>메소드의 리턴 타입이 void이면 실행 메소드이므로, 값으로 봐서는 절대 안 된다.</li>
  <li>메소드의 리턴 타입이 void가 아니라면 사용한 부분 통채로가 리턴값이다.</li>
</ul>


<h3>메소드의 목적</h3>
<ul>
  <li>메소드의재사용을 목적으로 두기에, 특정성을 부여하지 않는다. (목적에만 맞게)</li>
  <li>입력받지 않아도 되는 메소드에는 Scanner를 사용하지 않는다. (재사용 불가)</li>
</ul>


<h3>return이 필요한 상황</h3>
<ul>
  <li>사용하는 쪽에 로직의 결과를 전달해야 할 때.</li>
  <li>메소드의메소드 목적이 질문에 대한 답이 있는지</li>
  <ul><li>Ex) 3개의 정수의 뺄셈을 진행한다 -> 뺄셈 결과를 어떻게 사용할지 모르기에 result 값만 반환</li></ul>
  <li>메소드 내에서 모든 작업이 끝날 수 없을 땐</li>
</ul>


<h3>return이 필요하지 않은 상황</h3>
<ul>
  <li>사용한 쪽에 로직의 결과를 전달할 필요가 없을 때</li>
  <li>메소드의메소드 내에서 모든 작업이 완료될 때</li>
</ul>
