# 클래스, 인터페이스, 람다식 기본 이해하기!


<h3>추상 클래스란?</h3>
<ul>
  <li>추상 클래스 : 필드 안에 구현이 안 된 메소드가 선언되어 있는 클래스.</li>
  <li>추상 메소드 : 바디(중괄호)가 없우 구현이 되지 않은 메소드</li>
    <ul><li>반드시 재정의를 통해 구현을 해야지만 메모리에 할당되기 때문에</li></ul>
  <li>강제성 : 부모 클래스를 상속받은 자식 클래스가 추상 메소드를 따로 구현하지 않는 경우 에러를 발생</li>
</ul>



<h3>추상 클래스를 사용하는 이유?</h3>
<ul>
  <li>"강제성"을 부여하기 위해서 추상 메소드로 선언을 한다.</li>
  <li>에러를 강제적으로 줌으로써 추상 메소드에 바디를 선언해야 한다는 알림을 주어 이후 개발자가 확인을 할 수 있도록 한다</li>
</ul>



<h3>추상 클래스 선언</h3>
<pre><code>
abstract class 클래스명 {
    abstract 리턴타입 메소드명(매개변수, ...); // abstract를 붙여줌으로써 추상 메소드임을 알려줌
    // 일반 메소드도 선언 가능
}
</code></pre>


<h3>인터페이스(interface)란?</h3>
<ul>
  <li>인터페이스 : 틀</li>
  <li>추상 클래스를 고도화시킨 문법(=더욱 강한 강제성을 부여)</li>
  <ul>
    <li>상수와 추상메소드만 존재한다.</li>
    <li>구현은 인터페이스를 지정한 클래스에서 진행하고, 인터페이스를 다른 클래스에 지정할 때에는 implements 키워드를 사용한다.</li>
  </ul>
  <li>인터페이스는 타입이다.</li>
  <li>인터페이스는 부모타입이다.</li>
</ul>



<h3>인터페이스 선언</h3>
<pre><code>
public interface Pet {
	// 일반 변수로 볼 수 있지만, interface에서는 상수만 사용이 가능하기 때문에 변수->상수로 만들어주는 final이 생략되어 있다. 또한, 추상메소드 구현이 따로 되어 있지 않기 때문에 메모리에 올라가지 않아 static도 생략이 되어 있다
	final static int eyes = 2;
	int nose = 1;
	
	// interface에서는 추상 메소드만 사용이 가능하기 때문에 abstract가 생략됨
	public abstract void bang();
	public void giveYourHand();
	public void bite();
	public void sitDown();
	public void waitNow();
	public void getNose();
}
</code></pre>



<h3>추상 클래스와 인터페이스 간의 관계</h3>
<ul>
  <li>인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되어서 전부 다 구현을 해야 한다.</li>
  <li>일반적인 상황에서는 모든 것이 아닌, 필요한 메소드를 골라서 재정의해야하는 상황이 대다수이다.</li>
  <li>인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 바디를 만든다.</li>
  <li>그렇게 되면 강제성이 소멸되고 이 클래스를 상속받아 필드를 구현한다면, 골라서 재정의를 할 수 있다.</li>
  <li>이 때 중간에서 강제성을 없애주는 클래스를 추상 클래스로 선언하기로 하며, 추상 클래스 이름 뒤에는 'Adapter'를 붙여서 목적을 알려준다.</li>
</ul>



<h3>마커 인터페이스(Market Interface)란?</h3>
<ul>
  <li>클래스들을 그룹화하기 위한 목적으로 사용한다.</li>
  <li>인터페이스는 지정한 클래스의 부모이며, 모든 자식은 부모의 타입이므로 마커 인터페이스를 지정받은 클래스들이 하나의 타입으로 묶이게 된다.</li>
</ul>



<h3>내부 클래스(Inner Class)</h3>
<ul>
  <li>웹에서는 내부 클래스를 사용할 일이 별로 없지만, 익명 클래스를 이해하기 위한 기본 지식이 필요.</li>
  <li>하나의 클래스에서 a작업과 b작업이 있을 때에는 따로 분리하여 클래스로 만들지 않고, 클래스 안에 클래스를 선언하여 설계한다. 이 때 밖에 있는 클래스를 외부 클래스라고 하며, 안에 선언된 클래스를 내부 클래스라고 한다. 외부 클래스가 메모리에 할당되어야 내부 클래스를 객체화할 수 있기 때문에 클래스를 숨기기 위해서 내부 클래스를 사용하기도 하며, 이를 캡슐화 또는 은닉화라고 한다. 내부 클래스는 외부 클래스의 필드이기 때문에 외부 클래스의 필드는 자신의 필드처럼 가져다 사용할 수 있게 된다.</li>
  <li>메소드 안에서 클래스를 선언할 수도 있다.</li>
</ul>



<h3>익명 클래스(Anonymous Inner Class)</h3>
<ul>
  <li>이름이 없는 클래스이며, 구현되지 않은 필드를 구현하기 위해 일회성으로 생성되는 클래스이다.</li>
  <li>해당 클래스의 경우 기능을 한 번만 구현을 한 후에 필요할 때 갖다쓰면 되기 때문에 굳이 이름이 필요없어 익명 클래스이다.</li>
</ul>



<h3>다중 상속이란?</h3>
<ul>
  <li>여러 부모 클래스를 상속하는 것을 다중 상속이라고 한다.</li>
  <li>JAVA는 모호성 때문에 다중 상속을 지원하지 않는다.</li>
  <li>하지만 JDK8 버전부터는 인터페이스에 default 메소드 선언을 허용하며, 여러 개를 지정할 수 있는 인터페이스 특성상 다중 상속을 지원하는 것이나 다름이 없다.</li>
</ul>



<h3>모호성(ambiguity)이란?</h3>
<ul>
  <li>하나의 자식이 여러 부모를 상속받을 때 부모 필드에 동일한 이름의 필드가 있다면, 어떤 부모의 필드인지 알 수가 없다. 이를 모호성이라고 부른다.</li>
</ul>



<h3>모호성 해결방법</h3>
<ul>
  <li>상황 1 : 두 개의 인터페이스 내에 이름과 매개변수가 똑같은 메소드가 선언되어 있다.</li>
  <ul><li>해결 : 자식 클래스에서 재정의하여 사용한다.</li></ul>
  <li>상황 2 : 부모 클래스의 메소드와 인터페이스의 default 메소드의 이름, 매개변수가 똑같이 선언되어 있다.</li>
  <ul><li>해결 : 부모 클래스의 메소드가 사용된다.</li></ul>
</ul>



<h3>함수형 인터페이스(Functional interface)</h3>
<ul>
  <li>인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.</li>
  <li>이 때 @FunctionalInterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언할 수 있도록 제한해야 한다.</li>
</ul>



<h3>람다식(Lambda Expression)</h3>
<ul>
  <li>이름이 없는 메소드로서 변수처럼 사용이 가능하며, 매개변수로도 전달이 가능하다.</li>
  <li>함수형 인터페이스는 추상 메소드가 한 개만 선언되기 때문에 메소드 이름이 필요가 없다.</li>
  <li>따라서 람다식을 익명 메소드(Anonymous Method)라고도 부른다.</li>
</ul>



<h3>람다식 문법</h3>
<ul>
  <li>(매개변수 형식 나열, ...) -> 리턴값</li>
  <li>(매개변수 형식 나열, ...) -> {2개 이상의 문장 작성; return 리턴값; }</li>
</ul>
